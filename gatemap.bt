struct COLORIZATION {
    // check 11th byte for non-mini family in compounds
    ushort class_id                     <format=hex>;
    char unk0[0x02]                     <hidden=true>;
    ushort num_entries;
    struct COLOR_ENTRY {
        ushort type                     <format=hex>;
        if (type == (0x42 + class_id - 0x3A)) {
            uint source;
            // seems to always be 0x43?
            ushort unk                  <hidden=true>;
            float hue;
            float sat;
            float val;
        } else if (type == 0x2D)
            uint colorization;
    } colors[num_entries] <optimize=false>;
};

struct FILE {
    struct HEADER {
        byte unk0                       <hidden=true>;
        uint gate_id;
        byte unk1                       <hidden=true>;
        ushort gate_name_len            <hidden=true>;
        char prefix[0x1B]               <hidden=true>;
        char gate_name[gate_name_len - 0x1B] <bgcolor=cRed>;
        byte unk2                       <hidden=true>;
        ushort gate_icon_len            <hidden=true>;
        char gate_icon[gate_icon_len]   <bgcolor=cBlue>;
        COLORIZATION color              <fgcolor=cBlack>;
        byte unk3                       <hidden=true>;
        ushort desc_len                 <hidden=true>;
        char desc[desc_len]             <hidden=true>;
        byte unk4[0x16]                 <hidden=true>;
        uint wheel_num                  <hidden=true>;
        // unk4: sourceid, destid,
        // priority, tokens, flags
    } header <open=true>;
    struct WHEEL {
        ushort is_random                <hidden=true>;
        byte unk0[0x05]                 <hidden=true>;
        ushort num_levels               <hidden=true>;
        struct LEVEL {
            byte unk0[0x02]             <hidden=true>;
            byte unk1                   <hidden=true>;
            ushort level_name_len       <hidden=true>;
            char level_name[level_name_len] <bgcolor=cRed>;
            byte unk2                   <hidden=true>;
            ushort level_icon_len       <hidden=true>;
            char level_icon[level_icon_len] <bgcolor=cBlue>;
            COLORIZATION color          <fgcolor=cBlack>;
            byte unk3                   <hidden=true>;
            ushort desc_len             <hidden=true>;
            char desc[desc_len]         <hidden=true>;
            ushort type                 <hidden=true>;
            byte restricted[0x02]       <hidden=true>;
        } level[num_levels] <optimize=false>;
        if (is_random != 0x45 && is_random != 0x44)
            // get first four bits of first byte to get direction
            // 3_ = turn right, B_ = turn left
            byte unk1[0x11 + num_levels*4] <hidden=true, fgcolor=cRed>;
    } wheels[header.wheel_num] <optimize=false>;
    short class_id                      <hidden=true>;
    if (class_id < 0) {
        ushort class_name_len           <hidden=true>;
        char class_name[class_name_len];
    }
    byte unk0[7]                        <format=hex>;
    ubyte themes[6];
} file <bgcolor=cLtGray, open=true>;
